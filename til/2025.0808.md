포장(Wrapper) 클래스

박싱과 언박싱
```java
Integer bi = 10   // 자동 박싱
int i1 = bi       // 자동 언박싱
int i2 = bi + 20  // 자동 언박싱
```


# binary shearch (이진 검색)
- 전제 사항 : 배열의 모든 값은 정렬(sort) 되어있다. 


# java.util.Calendar
Java의 `java.util.Calendar` 클래스가 **singleton 객체가 아닌 이유**와 생성 방식에 대해 설명드리겠습니다.

***

## 왜 Calendar는 singleton이 아닌가?

- **시간 정보가 계속 변동되기 때문**입니다.  
  `Calendar` 객체는 현재 날짜와 시간을 표현하므로, 매번 새로운 시간 정보를 반영해야 합니다. 만약 하나의 객체(singleton)만을 공유한다면, 여러 코드나 스레드에서 그 객체의 상태(날짜/시간 필드)가 서로 영향을 주고받아 일관성과 동시성 문제가 발생할 수 있습니다.

***

## 생성 방식: Builder 패턴과 객체 수정

- 최신 Java에서는 `Calendar` 객체는 `Calendar.getInstance()` 등 팩토리 메서드를 통해 **매번 새로운 인스턴스**를 반환합니다.  
- 또한, 내부적으로 **builder 패턴**(예: `GregorianCalendar.Builder`)을 이용해 필요한 설정(타임존, Locale 등)을 지정하면서 Calendar 객체를 생성할 수도 있습니다.
- Calendar는 **mutable(수정 가능한) 객체**로, 하나의 객체에서 날짜·시간 필드를 계속 수정할 수 있습니다. 이 역시 singleton과는 맞지 않습니다.

***

## 정리

- **singleton이 아닌 이유:** 시간정보가 "실시간"으로 계속 바뀌고, 각기 다른 쓰임새나 설정용 별도 인스턴스가 필요해서.
- **생성패턴:** 일반적으로 팩토리 메서드(`getInstance`), 필요시 builder로 여러 인스턴스를 필요에 따라 생성함.
- **수정 가능:** 하나의 Calendar 객체의 상태는 언제든 바꿀 수 있으므로, 다양한 시나리오에서 동시에 쓸 수 없다.

즉, `Calendar`는 동시성 및 실시간성 요구 때문에 singleton 패턴을 사용하지 않고, 매번 생성해서 사용합니다. 


# java.util.Random

seed value? 

# 예외처리
컴파일, 런타임, 논리적

## JAVA의 런타임 오류
error : 개발자가 해결할 수 없는 치명적인 오류(코드로 수습 할 수 없는 심각한 오류)
exception : 개발자가 해결할 수 있는 오류(프로그램 코드로 수습 가능)
예외처리 : 에러는 어쩔 수 없지만, 예외가 발생하면 비정상적인 종료를 막고, 프로그램을 계속 진행할 수 있도록 우회 경로를 제공해서 정상적인 실행상태를 유지하는것


### Throwable
Throwable은 인터페이스가 아니라 클래스
Throwable은 Error와 Exception 객체에 상속됨.

#### Exception
checked와 unchecked 정리
unchecked Exception 이 많아진 이유 : 개발자들이 귀찮아해서.
unchecked Exception은 대부분 RuntimeException 을 상속받은 객체로 만들어저 있다.

#### 예외처리
정의 : 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것
목적 : 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지하는것

#### 예외처리 방법
1. 에외 처리하기 
2. 예외 떠넘기기 : 메서드에서 발생한 예외를 내부에서 처리하기가 부담스러울 때는 throws 키워드를 사용해 예외를 상위 코드 블록으로 양도하는 방법

##### catch bock의 순서도 중요!
구체적인 Exception 부터 작성해야함. 
if문과 for문과 같이 { }을 생략할 수없음.


# 제네릭 타입
제네릭 : 포괄적인(구체적인의 반대), 타입을 결정하지 않고 클래스를 설계
- 필드를선언할때 타입이 필요, 생성자의 매개변수 등에 타입이 들어감.
- 이러한 타입이 구체적이지 않고 포괄적인 타입으로 선언할 수 있다는 것
- 실제로 사용을 할때는 구체적인 타입이 결정이 되어야 하지만 설계할때는 구체적 타입을 언급하지 않고 사용할 때 구체적인 타입을 결정함.

## 제네릭 타입의 의미
- 하나의 코들르 다양한 타입의 객체에 재사용하는 객체 지향기법
-결정되지 않은 타입을 파라미터를 가지는 클래스와 인터페이스를 제네릭 타입이라고 함.
- 클래스, 인터페이스, 메서드를 정의할 때 타입을 변수로 사용

## 제네릭 타입의 장점
- 컴파일할 때 타입을 점검하기 때문에 실행 도중 발생할 오류 사전방지
    - 타입안정성 제공
- 불필요한 타입 변환이 없어 프로그램 성능 향상
    - 불필요한 타입 검증이 없어 성능향상.
