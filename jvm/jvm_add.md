JVM의 주요 구성 요소들은 밀접하게 상호작용하며 자바 프로그램의 실행을 관리합니다. 크게 세 가지 핵심 구성 요소와 네이티브 영역과의 인터페이스를 통해 전체 시스템이 작동합니다.

JVM의 핵심 구성 요소 및 상호작용:

*   **클래스 로더 (Class Loader)**:
    *   자바 프로그램이 `.class` 파일 형태로 컴파일된 **자바 바이트 코드**를 JVM으로 가져오는 역할을 합니다.
    *   단순히 로딩만 하는 것이 아니라, **링크 (Linking)** 및 **초기화 (Initialization)** 과정까지 담당합니다.
    *   모든 클래스를 한 번에 로딩하는 것이 아니라, 프로그램 실행 중 필요할 때마다 동적으로 클래스를 로딩하고 링크합니다. 이러한 동적인 로딩 시점은 자바의 독특한 특징이자 강력한 확장성과 유연성을 제공하는 핵심적인 부분입니다. 예를 들어, 네트워크에서 클래스 파일을 읽어와 작동 중인 소프트웨어를 멈추지 않고 새로운 코드를 추가하거나 변경할 수 있게 합니다.
    *   클래스 로딩 과정 중 오류가 발생하면 해당 클래스뿐만 아니라 이에 의존하는 다른 클래스들의 작동에도 문제가 생길 수 있어 운영상 중요한 이슈가 될 수 있습니다.
    *   클래스가 로딩되면 해당 클래스의 메서드(함수)는 **런타임 데이터 영역** 내의 **메서드 영역**에 적재됩니다.

*   **런타임 데이터 영역 (Runtime Data Area)**:
    *   JVM 구성 요소 중 **가장 중요**하며, 자바 바이트 코드를 실행하는 데 필요한 데이터를 저장하는 메모리 영역입니다. JVM 내에서 이 영역의 관리를 알아서 수행합니다.
    *   주요 하위 영역들은 다음과 같이 상호작용합니다:
        *   **힙 영역 (Heap Area)**:
            *   **객체 인스턴스** (우리가 `new` 키워드로 동적으로 생성하는 인스턴스)가 저장되는 공간입니다.
            *   JVM 내에서 **가장 큰 메모리 영역**을 차지하며, 기가바이트 단위의 용량을 가집니다.
            *   **가비지 컬렉터 (Garbage Collector)**가 주로 이 힙 영역을 관리하며, 사용되지 않는 객체 인스턴스를 회수하여 메모리를 재활용합니다. 가비지 컬렉터의 작동 원리를 아는 것이 중요하며, 때로는 "스탑 더 월드(Stop The World)" 현상으로 인해 JVM이 일시적으로 멈춰 서비스 장애로 이어질 수도 있습니다.
        *   **메서드 영역 (Method Area)**:
            *   클래스 로더에 의해 로딩된 **클래스의 메서드(함수)**들이 적재되는 공간입니다.
            *   `런타임 상수 풀 (Runtime Constant Pool)`을 포함하며, 문자열 상수 같은 것들이 이곳에 저장됩니다. 문자열 상수를 많이 사용할수록 이 영역의 메모리 사용량이 증가할 수 있습니다.
            *   "퍼머넌트 메타스페이스(Permanent Metaspace)" 영역으로 분류되기도 하며, 스프링 프레임워크의 리플렉션과 같은 고급 기능과도 관련이 있습니다.
        *   **스택 영역 (Stack Area)** 및 **프로그램 카운터 레지스터 (Program Counter Register, PC Register)**:
            *   이 두 영역은 **스레드 (Thread)**와 밀접하게 관련되어 있습니다.
            *   멀티스레딩 환경에서 각 스레드마다 독립적인 스택과 PC 레지스터를 가집니다. 이는 각 스레드의 실행 흐름과 관련된 정보를 저장하는 역할을 합니다.
            *   스택 영역은 메서드 호출 정보, 지역 변수 등을 저장하며, PC 레지스터는 현재 실행 중인 명령어의 주소를 가리킵니다.

*   **실행 엔진 (Execution Engine)**:
    *   런타임 데이터 영역에 적재된 **자바 바이트 코드**를 실제 컴퓨터의 CPU가 이해할 수 있는 **머신 코드 (기계어)**로 번역하고 실행하는 역할을 합니다.
    *   주요 구성 요소는 **JIT (Just-In-Time) 컴파일러**입니다.
    *   자바 바이트 코드는 가상 머신이 인식하는 코드이므로, CPU가 실제 연산을 수행하려면 다시 한번 번역이 필요합니다.
    *   JIT 컴파일러는 인터프리터 방식과 컴파일러 방식을 혼합하여 사용하며, 특히 **자주 수행되는 코드**는 미리 머신 코드로 번역하여 저장해두었다가 다음 실행 시에 바로 사용할 수 있게 함으로써 **자바의 성능 향상에 결정적인 역할**을 합니다. 자바가 "하이브리드 언어"로 불리는 이유이기도 합니다.

*   **JNI (Java Native Interface) 및 네이티브 영역 (Native Area) 인터페이스**:
    *   JVM은 자바 언어로만 모든 작업을 수행할 수 없으므로, 운영 체제 수준의 API를 호출해야 할 때가 있습니다.
    *   JNI는 이러한 **네이티브 영역** (주로 C++ 등으로 구현된 영역)과의 인터페이스를 제공하여, 자바 프로그램이 운영체제 API를 호출하거나 동적 라이브러리(DLL, SO 등)와 연동할 수 있도록 합니다.
    *   이 부분은 자바 외에 C++ 지식이 필요하고 보안과도 직결되는 복잡한 영역이므로 일반적인 자바 수업 범위에서는 깊이 다루지 않습니다.

이처럼 클래스 로더가 바이트 코드를 로딩하고 런타임 데이터 영역에 배치하면, 실행 엔진이 이를 번역하여 CPU에서 실행하고, 가비지 컬렉터는 메모리를 관리하며, 필요에 따라 JNI를 통해 네이티브 시스템과 상호작용하며 전체 자바 애플리케이션이 구동됩니다.


런타임 데이터 영역, 특히 힙 메모리는 JVM의 성능과 운영 안정성에 지대한 영향을 미칩니다.

JVM의 **런타임 데이터 영역 (Runtime Data Area)**은 JVM 구성 요소 중 **가장 중요**하며, 자바 바이트 코드를 실행하는 데 필요한 데이터를 저장하는 핵심 메모리 영역입니다. 이 영역의 관리는 JVM 내에서 자동으로 이루어집니다.

특히 **힙 영역 (Heap Area)**은 런타임 데이터 영역 내에서 **가장 큰 메모리 영역**을 차지하며, 그 용량은 일반적으로 **기가바이트 단위**에 이릅니다. 우리가 `new` 키워드를 사용하여 동적으로 생성하는 모든 **객체 인스턴스**는 바로 이 힙 영역에 저장됩니다.

힙 메모리는 다음 두 가지 주요 측면에서 JVM 성능에 영향을 미칩니다:

*   **가비지 컬렉션 (Garbage Collection)의 역할 및 성능**:
    *   힙 영역은 주로 **가비지 컬렉터 (Garbage Collector)**에 의해 관리됩니다. 가비지 컬렉터는 더 이상 사용되지 않는 객체 인스턴스를 힙에서 회수하여 메모리를 재활용하는 역할을 합니다.
    *   가비지 컬렉터의 작동 원리를 이해하는 것은 **운영 관점**에서 매우 중요합니다.
*   **"스탑 더 월드 (Stop The World)" 현상**:
    *   가비지 컬렉션 과정에서 "스탑 더 월드"라는 현상이 발생할 수 있습니다. 이 현상이 발생하면 **JVM의 실행이 일시적으로 완전히 멈추게 됩니다**.
    *   이러한 일시적인 멈춤은 **그 자체로 서비스 장애로 간주될 수 있기 때문에** 매우 중요하게 관리되어야 할 성능 저하 요인입니다. 효율적인 가비지 컬렉션 전략과 힙 메모리 설정은 JVM 기반 애플리케이션의 성능과 안정성을 확보하는 데 필수적입니다.

또한, 런타임 데이터 영역의 다른 부분인 **메서드 영역 (Method Area)**도 간접적으로 메모리 사용량에 영향을 줄 수 있습니다. 메서드 영역에는 로딩된 클래스의 메서드뿐만 아니라 **런타임 상수 풀 (Runtime Constant Pool)**도 포함됩니다. 만약 프로그램이 문자열 상수와 같은 데이터를 많이 사용한다면, 이들이 런타임 상수 풀에 적재되면서 **메모리 사용량이 증가할 수 있습니다**. 이는 직접적인 성능 저하보다는 메모리 사용량 증가를 통한 잠재적인 운영 이슈와 연관될 수 있습니다.


JVM 구성 요소 심층 분석 스터디 가이드
1. 핵심 개념 정리
JVM 구성 요소의 큰 틀

JVM은 크게 세 가지 주요 구성 요소로 이루어져 있습니다:

    클래스 로더 (Class Loader): .class 파일을 로딩하고 링크 및 초기화를 담당합니다.
    런타임 데이터 영역 (Runtime Data Area): 프로그램 실행 중에 사용되는 데이터를 저장하는 메모리 영역입니다. JVM 구성 요소 중 가장 중요하다고 언급됩니다.
    실행 엔진 (Execution Engine): 바이트코드를 실행 가능한 기계어로 변환하고 실행합니다.

이 외에 JNI (Java Native Interface)를 통한 네이티브 영역과의 인터페이스가 있지만, 수업 범위 밖으로 언급됩니다.
클래스 로더 (Class Loader)

    역할: .class 파일 (자바 바이트 코드)을 JVM 메모리로 로딩하고, 링크(Link) 및 초기화(Initialization) 과정을 수행합니다.
    특징:
    자바의 독특한 특징 중 하나로, 기술적으로 매우 중요합니다.
    코틀린 등 다른 하이레벨 언어도 자바 바이트 코드로 번역되어 JVM 위에서 작동할 수 있게 합니다.
    동적 로딩: 프로그램 실행 중에 필요한 클래스만 동적으로 로딩합니다. 모든 클래스를 미리 로딩하지 않습니다.
    로딩, 링크, 초기화:
    로딩 (Loading): .class 파일을 읽어 JVM 메모리에 올립니다.
    링크 (Linking): 검증(Verification), 준비(Preparation), 해석(Resolution) 단계를 포함합니다.
    초기화 (Initialization): 클래스의 정적 변수를 초기화하고 정적 블록을 실행합니다.
    운영 이슈: 클래스 로딩 과정에서 오류 발생 시 해당 클래스뿐만 아니라 의존성 있는 다른 클래스까지 영향을 받을 수 있어 운영상 문제가 될 수 있습니다.
    확장성 및 유연성: 런타임에 소프트웨어를 멈추지 않고 새로운 코드를 로드하고 언로드할 수 있게 하여 자바의 강력한 확장성과 유연성의 중심에 있습니다.

런타임 데이터 영역 (Runtime Data Area)

    중요성: JVM 구성 요소 중 가장 중요하며, 특히 가비지 컬렉터와 관련하여 운영 관점에서 중요합니다.
    주요 영역:
    힙 영역 (Heap Area):
    객체 인스턴스 (예: new 키워드로 생성된 객체)가 저장되는 공간입니다.
    가장 크기가 크며 (기가바이트 단위), 가비지 컬렉터가 관리하는 주된 영역입니다.
    메소드 영역 (Method Area):
    클래스 정보 (클래스 구조, 메소드 코드, 필드 정보 등) 및 정적 변수가 저장됩니다.
    "Permanent Metaspace" 영역과 관련이 있으며, 리플렉션과 같은 고급 기능에서 중요하게 다뤄질 수 있습니다.
    런타임 상수 풀 (Runtime Constant Pool)도 이 영역 내에 존재하며, 문자열 상수 등이 저장됩니다.
    스택 영역 (Stack Area):
    각 스레드마다 독립적으로 생성됩니다.
    메소드 호출 시 생성되는 프레임 (지역 변수, 매개 변수, 연산 결과 등)이 저장됩니다.
    PC 레지스터와 함께 스레드와 관련이 깊습니다. (본 수업에서는 심도 있게 다루지 않음)
    PC 레지스터 (Program Counter Register):
    각 스레드마다 독립적으로 생성됩니다.
    현재 실행 중인 JVM 명령어의 주소를 저장합니다.
    스택 영역과 함께 동시성(멀티쓰레딩) 논의 시 중요하지만, 본 수업에서는 심도 있게 다루지 않습니다.
    네이티브 메소드 스택 (Native Method Stack): JNI를 통해 네이티브 메소드를 호출할 때 사용되는 스택 영역입니다. (본 수업에서는 심도 있게 다루지 않음)
    가비지 컬렉터 (Garbage Collector, GC): 힙 영역에 있는 더 이상 사용되지 않는 객체 인스턴스를 자동으로 회수하여 메모리를 관리합니다. Stop-The-World 현상은 GC 작동 시 JVM이 일시적으로 멈추는 현상으로, 운영상 장애로 간주될 수 있습니다.

실행 엔진 (Execution Engine)

    역할: 런타임 데이터 영역에 있는 바이트 코드를 실행합니다.
    구성 요소:
    인터프리터 (Interpreter): 바이트 코드를 한 줄씩 읽어 기계어로 번역하고 실행합니다.
    JIT 컴파일러 (Just-In-Time Compiler):
    자바의 성능 향상에 결정적인 역할을 합니다.
    자주 실행되는 바이트 코드를 통째로 기계어로 컴파일하여 캐시하고, 이후에는 재번역 없이 컴파일된 코드를 바로 실행합니다. 이는 자바를 하이브리드 언어(인터프리터 + 컴파일러)로 보게 하는 이유입니다.
    가비지 컬렉터 (Garbage Collector, GC): 런타임 데이터 영역의 힙에 있는 사용되지 않는 객체를 회수합니다.

2. 퀴즈 (단답형)

    JVM의 세 가지 핵심 구성 요소를 나열하고, 그중 가장 중요하다고 언급된 구성 요소는 무엇인지 설명하세요.
    클래스 로더가 담당하는 주요 3단계 과정(로딩, 링크, 초기화)을 간단히 설명하고, 자바에서 클래스 로딩이 '동적'이라는 의미는 무엇인지 서술하세요.
    가비지 컬렉터(GC)의 주요 역할은 무엇이며, GC가 작동할 때 발생할 수 있는 'Stop-The-World' 현상은 운영상 어떤 문제로 이어질 수 있습니까?
    런타임 데이터 영역 중 new 키워드를 통해 동적으로 생성된 객체 인스턴스가 저장되는 영역은 어디이며, 이 영역의 특징(크기, 관리 주체)을 간략히 설명하세요.
    메소드 영역에 저장되는 주요 정보는 무엇이며, 런타임 상수 풀(Runtime Constant Pool)은 어느 영역에 속하고 어떤 데이터를 저장하는지 설명하세요.
    스택 영역과 PC 레지스터가 각 스레드마다 독립적으로 생성되는 이유는 무엇이며, 이 두 영역이 어떤 시스템적인 논의(본 수업 범위 외)와 관련이 깊다고 언급되었습니까?
    실행 엔진의 주요 구성 요소 중 인터프리터와 JIT 컴파일러의 역할 차이를 설명하고, JIT 컴파일러가 자바 성능 향상에 기여하는 방식은 무엇입니까?
    자바 바이트 코드가 JVM에 의해 실행되기 전, CPU가 실제 연산을 수행하기 위해 추가적으로 필요한 번역 과정은 무엇이며, 이 과정을 담당하는 실행 엔진 구성 요소는 무엇입니까?
    클래스 로더의 장점 중 하나로 언급된 "확장성"과 "유연성"이 구체적으로 어떤 상황에서 발휘될 수 있는지 예시를 들어 설명하세요.
    JNI(Java Native Interface)의 역할은 무엇이며, 이 인터페이스가 본 수업 범위에서 심도 있게 다루어지지 않는 이유는 무엇입니까?

3. 퀴즈 정답 (단답형)

    JVM의 세 가지 핵심 구성 요소는 클래스 로더, 런타임 데이터 영역, 실행 엔진입니다. 이 중 가장 중요하다고 언급된 구성 요소는 런타임 데이터 영역입니다.
    클래스 로더의 3단계는 로딩(.class 파일 읽기), 링크(검증, 준비, 해석), 초기화(정적 변수 초기화)입니다. 자바에서 클래스 로딩이 동적이라는 것은 프로그램 실행 중에 필요한 클래스만 그때그때 로딩한다는 의미입니다.
    가비지 컬렉터(GC)는 힙 영역에서 더 이상 사용되지 않는 객체를 자동으로 회수하여 메모리를 관리합니다. 'Stop-The-World' 현상은 GC 작동 시 JVM이 일시적으로 멈추는 것으로, 사용자 요청 처리 지연 등 운영상 장애로 이어질 수 있습니다.
    new 키워드로 생성된 객체 인스턴스는 힙 영역에 저장됩니다. 힙 영역은 JVM 런타임 데이터 영역 중 가장 크기가 크고(기가바이트 단위), 가비지 컬렉터의 주요 관리 대상입니다.
    메소드 영역에는 클래스 구조, 메소드 코드, 필드 정보, 정적 변수 등이 저장됩니다. 런타임 상수 풀은 메소드 영역 내에 존재하며, 문자열 상수와 같은 상수 데이터를 저장합니다.
    스택 영역과 PC 레지스터는 각 스레드마다 독립적으로 생성되어 스레드별 실행 상태를 관리합니다. 이 두 영역은 멀티쓰레딩과 동시성(Concurrency) 논의 시 중요하게 다루어집니다.
    인터프리터는 바이트 코드를 한 줄씩 번역하여 실행하는 반면, JIT 컴파일러는 자주 실행되는 코드를 기계어로 컴파일하여 저장 후 재사용합니다. JIT 컴파일러는 반복적인 번역 오버헤드를 줄여 자바 성능 향상에 기여합니다.
    자바 바이트 코드가 CPU가 이해할 수 있는 실질적인 기계어로 번역되는 과정은 JIT 컴파일러에 의해 수행됩니다. 인터프리터도 기본적으로 번역을 하지만, JIT 컴파일러가 성능 최적화를 위해 이 역할을 담당합니다.
    클래스 로더의 확장성과 유연성은 런타임에 실행 중인 소프트웨어를 멈추지 않고 네트워크에서 .class 파일을 읽어 로딩하거나, 새로운 코드를 동적으로 올리고 내리는 상황에서 발휘될 수 있습니다.
    JNI(Java Native Interface)는 자바 코드에서 C/C++과 같은 네이티브 코드를 호출할 수 있게 하는 인터페이스입니다. 본 수업에서는 C/C++ 언어에 대한 지식과 보안 이슈가 필요하여 수업 범위를 넘어선다고 판단되어 심도 있게 다루어지지 않습니다.

4. 에세이 형식 질문 (답변 없음)

    JVM의 세 가지 핵심 구성 요소(클래스 로더, 런타임 데이터 영역, 실행 엔진) 각각의 중요성과 상호작용 방식에 대해 심층적으로 논하고, 각 구성 요소가 자바 애플리케이션의 성능과 안정성에 미치는 영향을 분석하시오.
    클래스 로더가 자바의 "동적 로딩"이라는 특징을 구현하는 방식과 이로 인해 얻을 수 있는 기술적, 운영적 이점에 대해 설명하시오. 또한, 클래스 로딩 과정에서 발생할 수 있는 오류가 시스템 전반에 미치는 영향과 그 대응 방안에 대해 서술하시오.
    런타임 데이터 영역 내의 힙(Heap) 영역, 메소드(Method) 영역, 스택(Stack) 영역의 기능과 목적을 비교하고 설명하시오. 특히, 가비지 컬렉터가 힙 영역을 관리하는 원리와 Stop-The-World 현상이 발생하는 배경 및 해결 노력에 대해 논하시오.
    실행 엔진의 주요 구성 요소인 인터프리터와 JIT 컴파일러가 자바 바이트 코드를 실행하는 방식의 차이를 설명하고, JIT 컴파일러가 자바를 "하이브리드 언어"로 만드는 데 어떻게 기여하며 성능 최적화에 어떤 역할을 하는지 구체적인 메커니즘을 들어 설명하시오.
    JVM 구성 요소 중 본 수업에서 심도 있게 다루지 않는 JNI와 PC 레지스터/네이티브 메소드 스택의 역할에 대해 간략히 설명하고, 이러한 고급 주제들이 실제 운영 환경에서 언제, 어떤 맥락에서 중요하게 다루어질 수 있는지 예상하여 논하시오.

5. 핵심 용어 Glossary

    JVM (Java Virtual Machine): 자바 바이트 코드를 실행하는 가상 머신. 운영 체제에 독립적으로 자바 애플리케이션을 실행할 수 있게 합니다.
    클래스 로더 (Class Loader): .class 파일(자바 바이트 코드)을 JVM 메모리로 로딩하고 링크 및 초기화를 담당하는 JVM의 핵심 구성 요소.
    런타임 데이터 영역 (Runtime Data Area): JVM이 프로그램을 실행하면서 사용하는 데이터를 저장하는 메모리 영역. 힙, 메소드, 스택, PC 레지스터, 네이티브 메소드 스택 등으로 구성됩니다.
    실행 엔진 (Execution Engine): 런타임 데이터 영역에 로드된 바이트 코드를 실행하는 JVM 구성 요소. 인터프리터, JIT 컴파일러, 가비지 컬렉터로 이루어집니다.
    자바 바이트 코드 (Java Bytecode): .java 소스 코드를 컴파일하여 생성되는 .class 파일 형태의 코드. JVM이 이해하고 실행할 수 있는 중간 언어입니다.
    JNI (Java Native Interface): 자바 애플리케이션에서 C/C++과 같은 네이티브 코드 라이브러리를 호출하고 연동할 수 있게 하는 표준 프로그래밍 인터페이스.
    로딩 (Loading): 클래스 로더가 .class 파일을 읽어 JVM 메모리에 올리는 과정.
    링크 (Linking): 로딩된 클래스 파일의 유효성을 검사하고(검증), 클래스 변수를 초기화할 공간을 할당하며(준비), 심볼릭 레퍼런스를 직접 참조로 바꾸는(해석) 과정.
    초기화 (Initialization): 클래스 변수의 실제 값을 할당하고, 정적 블록을 실행하는 과정.
    힙 영역 (Heap Area): JVM 런타임 데이터 영역 중 가장 큰 부분으로, 객체 인스턴스(인스턴스 변수)가 동적으로 할당되고 저장되는 영역. 가비지 컬렉터의 주요 관리 대상입니다.
    메소드 영역 (Method Area): JVM 런타임 데이터 영역 중 하나로, 클래스 정보(클래스 구조, 메소드 코드, 필드 정보, 정적 변수) 및 런타임 상수 풀 등이 저장됩니다. Java 8 이후로는 Metaspace로 불리기도 합니다.
    스택 영역 (Stack Area): 각 스레드마다 독립적으로 생성되며, 메소드 호출 시 생성되는 스택 프레임(지역 변수, 매개 변수, 연산 중간 결과 등)이 저장되는 영역.
    PC 레지스터 (Program Counter Register): 각 스레드마다 독립적으로 존재하며, 현재 실행 중인 JVM 명령어의 주소(또는 다음 실행할 명령어의 주소)를 저장하는 레지스터.
    네이티브 메소드 스택 (Native Method Stack): 자바 코드가 JNI를 통해 네이티브 메소드를 호출할 때 사용되는 스택 영역.
    가비지 컬렉터 (Garbage Collector, GC): 힙 영역에서 더 이상 참조되지 않는(사용되지 않는) 객체들을 자동으로 찾아내 메모리를 회수하는 JVM의 메모리 관리 도구.
    Stop-The-World: 가비지 컬렉터가 객체 회수를 위해 JVM 애플리케이션의 모든 스레드 실행을 일시적으로 중단시키는 현상.
    인터프리터 (Interpreter): 실행 엔진의 구성 요소로, 바이트 코드를 한 줄씩 읽어 바로 기계어로 번역하고 실행하는 방식.
    JIT 컴파일러 (Just-In-Time Compiler): 실행 엔진의 구성 요소로, 자주 실행되는 바이트 코드 부분을 감지하여 통째로 기계어로 컴파일하고 캐시하여 이후에는 번역 없이 빠르게 실행될 수 있도록 하는 컴파일러. 자바 성능 향상에 크게 기여합니다.
    런타임 상수 풀 (Runtime Constant Pool): 메소드 영역 내에 존재하며, 클래스 파일의 상수 풀(constant pool)이 런타임에 동적으로 확장된 형태로, 문자열 상수나 클래스, 메소드에 대한 심볼릭 레퍼런스 등을 저장합니다.
    동시성 (Concurrency): 여러 작업이 동시에 진행되는 것처럼 보이는 것. 멀티쓰레딩 환경에서 스택 영역과 PC 레지스터의 역할이 중요하게 다루어집니다.
    리플렉션 (Reflection): 자바 프로그램이 런타임에 자신의 구조(클래스, 메소드, 필드 등)를 검사하고 조작할 수 있도록 하는 기능. 메소드 영역과 관련이 있습니다.